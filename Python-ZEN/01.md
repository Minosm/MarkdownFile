听起来很简单，但是很重要；

越是简单，越是重要。

---

基础语法

函数

模块

面向对象编程

网络编程

并发编程（必备基本功）

---





**顺势而为**

信安是趋势~	

---



**存储器是 IO设备；**



操作系统 + 计算机 硬件 = 平台

程序要**跨平台**



python跨平台贼强！



CPU（计算机组成原理那部分，还有计算机网络那部分都没好好学，怪不得还差点，之后补上！）



CPU指令集分两种

- 精简指令集（如ARM）
- 复杂指令集（X86）



PC是复杂指令集，然鹅，sever用的是精简指令集？？

> 服务器的要求是稳定和处理速度快，并不需要它的图形能力很强，所以一般服务器的cpu整数运算能力强，浮点运算能力甚至不如PC



中国 指令集 or 硬件比较弱

X86是市面上常见的计算机架构



一次运算多少位，32 0r 64





运算指令集，控制指令集

OS和CPU的指令集是对应的

应用程序 只对应 了运算指令集

不能直接控制硬件



CPU内核态（开放所有指令集），运行 os

CPU用户态（只开放运算相关指令集），允许app

切换？

PSW寄存器，频繁状态转换？？





本身不能操作硬件，调用os功能，切换内核态；API

hacker

> 网卡是外部设备！！！
>
> 用于通信的，所以和CPU沟通的时候其实，需要通过总线



多重总线？

> 用户态：用户程序在用户态下运行，仅仅只能执行cpu整个指令集的一个子集，该子集中不包含操作硬件功能的部分。
>
> 因此，一般情况下，在用户态中有关I/O和内存保护（操作系统占用的内存是受保护的，不能被别的程序占用），当然，在用户态下，将PSW中的模式设置成内核态也是禁止的。



> 用户态下工作的软件不能操作硬件，但是我们的软件比如暴风影音，一定会有操作硬件的需求，比如从磁盘上读一个电影文件，那就必须经历从用户态切换到内核态的过程，为此，用户程序必须使用系统调用（**system call**），系统调用陷入内核并调用操作系统，TRAP指令把用户态切换成内核态，并启用操作系统从而获得服务。
>
> 请把的系统调用看成一个特别的的过程调用指令就可以了，该指令具有从用户态切换到内核态的特别能力。



> 对用户来说一个有两个线程的cpu就相当于两个cpu，



进程是**资源单位**而线程才是cpu的**执行单位**

(**进程是资源分配的最小单位，线程是CPU调度的最小单位**)

> 多线程运行cpu保持两个不同的线程状态，可以在纳秒级的时间内来回切换，速度快到你看到的结果是并发的，伪并行的，然而多线程不提供真正的并行处理，一个cpu同一时刻只能处理一个进程（一个进程中至少一个线程）



线程池？

现代操作系统中，进程支持多线程

多线程，共享全局变量（进程资源分配最小单位（不共享全局变量））



进程实体：

- 线程集
- 资源集

（线程共享资源集）

主线程？

线程消耗资源更大，进程是为了提高并发能力；

（进程创建需要，虚拟地址空间、页表、物理内存etc）

线程是一种轻量化的并发实体！

线程去共享进程的资源，（资源消耗少，也可以并发）

消耗时间不同（创建线程的速度更快一些）

---

线程更接近执行流

一个进程只要有一个线程（主线程）

main函数所在的线程，是主线程



其他线程都是pthread_create 创建的



PCB（process control block）

~~~mermaid
graph TB
	A[代码]-.创建PCB.->B[进程]
	B--创建执行流,分配资源-->C[资源]
~~~



进程大都在内核态创建（可能是由OS创建的）

线程私有的



<img src="D:\File_Recv\日语学习\image-20201116082732230.png" alt="image-20201116082732230" style="zoom:25%;" />



- Linux里线程叫做LWP（轻量级进程）
- 纯用户空间多线程
- go语言，混合版多线程



线程对应内核调度实体？

纯用户多线程，多个线程只对应一个调度实体（协程方案）？？

---

调度实体？？（可以理解为PCB）

以 Linux为例

进程使用PCB（进程控制块）去描述，操作系统只能感知PCB的存在，

所以每个进程都要实例化一个PCB结构体；

Linux线程，实际上也是用PCB 描述，只是轻量化的PCB 某些变量处理和PCB 略有不同，函数也有些不同。

---



GO协程方案（混合版）复杂？







协程？

**线程**创建的执行体，就是协程（**用户态线程**）操作系统对协程一无所知

协程的出现是因为，内核态与用户态的频繁切换（密集型运算内核在资源调度上比较耗费时间）很麻烦，不如直接在用户空间里虚拟线程



**线程池**

一个任务队列，那些线程一起创建，之后一起销毁？

因为线程的创建与销毁也需要时间，所以我们通过线程池来减少耗时；

线程处理任务的时间远小于创建与销毁的时间；



创建线程越多，单个耗时可能也会越多；

在衡量 任务量 与 线程池耗时 之后，可以选出线程池创建的最优数量——一般是

2*CPU数量；



> 许多计算机利用CMOS存储器来**保持当前时间和日期**。CMOS存储器和递增时间的电路由一小块**电池驱动**，所以，即使计算机没有加电，时间也仍然可以正确地更新

> **CMOS还可以保存配置的参数，比如，哪一个是启动磁盘等**，之所以采用CMOS是因为它耗电非常少，一块工厂原装电池往往能使用若干年，但是当电池失效时，相关的配置和时间等都将丢失

> 仅当系统未连接任何其他电源时才使用CMOS电池。因此，大多数情况下它们根本不会放电，为此设计的电池可以在架子上放置数年，而不会损失大量电量。在拔下PC并发现BIOS设置已重置之前，您可能不会知道电池已耗尽。

> 它们的使用寿命通常约为10年左右

NVMe的全称是Non-Volatile Memory Express，如果翻译过来就是非易失性内存主机控制器接口规范

存储设备接口规范 sas？ sata？



> Over-provisioning,是指固态硬盘内部存在的,由主控芯片控制的,用户不可操作的隐藏空间,这部分空间就是用于主控各种优化机制的操作,诸如GC回收,磨损均衡等
>
> op预留空间

雷电3 只支持typeC



磁盘阵列 raid1 和 raid0

- raid0
  - 三倍写入（同时写）2-3个硬盘
- raid1
  - 同时写两个，不容易丢失，但是慢还占地方；
- raid10
  - 4块，先 两两raid1，再raid0
- raid5 0r 6
  - 类似于raid0 但有验证
  - 每个校验码都放在不同的盘里，只坏掉一个盘，还是可以恢复数据的
  - 重建速度慢，还容易失败

LMR PMR SMR

平躺着的，垂直立体的，叠瓦的（机械硬盘）

SLC MLC TLC QLC（固态硬盘的四种类型）

容量与速度永远是矛盾的；

速度越慢，容量越大，量子计算机类似；	

三星的tlc略强；































我感觉我就是有病，，，，哈哈哈哈哈

蒜了，别恶心人了，做你自己不好么？







协程类似于小的线程，进程是小的进程，都是为了减少内核态和用户态切换 耗费的资源与时间

切换需要保存状态，还需要更新快表、缓存（切换内存地址空间）

PCB是数据结构，便于进程运行；

线程需要TCB,, （Linux是=直接用阉割版PCB）





协程实现了 轻量灵活的 用户态调度的多任务模型

高并发成为常态时，协程调度模型被广泛关注；

---

IO多路复用？？

高性能网络服务器？

- 多线程，需要频繁上下文切换，代价高
- 单线程
  - 专注于DMA 控制器
- select poll epoll？？？
  - select 拷贝到内核



**Linux内核源码情景分析（毛德操）**











斟一壶苦酒，弹一曲忧伤。

等不到雪落，看不见烽火；

斯人已逝，空余

决定了，我要成为大佬那样乐观向上的人。

希望张雨朦同学可以过上自己喜欢的生活。。。

---

还是坚持下去，无论结果如何……

我需要让自己处在一种状态中，一种动态的，所以不会被淘汰掉的，状态

就是每天都刻苦一些，这样一辈子。

拒绝放纵与骄奢

认真对待自己和人生

---

只需要专精一个方面，暂时不需要全部吃透，所以没必要去焦虑！

---

意识与感受都不一定是真实的，会产生很多的误差。

从目的来看，感觉与意识的存在 是为了帮助人类在自然界更好地存在与生活；

所以，当你过度地依赖于感觉判断以至于在 生活实践中 发生了不愉快、整体上不利于个体发展的冲突，

你应该更尊重 你的客观实践（找到真正符合自身健全发展的解决方案），而非单调地依赖意识，

否则就是本末倒置了。。

---

催眠术—— 艺术会让人更容易被暗示；

所以可以通过，音乐 或 诗歌实现催眠？、









薄伽丘

十日谈

弗洛伦萨

鼠疫



“Cave Cave Deus Videt” 小心，神在看着你	

关闭终端：CTRL + Z

python的变量名要**小写**

