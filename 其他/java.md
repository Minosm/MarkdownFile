类

模板、抽象

八个基本数据类型，其他的属于引用类型

char保留一个字

类、集合 —— 引用类型，传递 地址

实例 是具体的，可以使用的



人——类

张三——实例（对象）

值类型 —— 拷贝副本，改变副本



get 为什么要return

get set？



成员方法、构造方法；

构造方法 无返回值 类名作为返回值，不需要手动调用；用于初始化

java只支持单继承



接口 是 一种约定

只有声明，没有实现；



具有抽象方法的类一定是抽象类；

抽象类

> abstract class 名 （）；
>
> 接口/抽象类
>
> 子类继承，必须实现；
>
> 抽象类？子类的访问修饰符必须大于或者等于父类

抽象类构造函数的存在意义，

是子类构造方法要继承父类成员变量并赋值；

抽象方法也要被 abstract修饰；

抽象方法只能在抽象类中存在，因此有抽象方法的只能是抽象类。

子类一定实现，除非也是抽象类；

抽象类 一定是父类，也可以是子类；

---

抽象类无抽象方法，则往往用于设计需求；

设计时，从需求出发，抽象出抽象类；

代码重用；

---

接口？？

C++ 多个父类，

接口相当于一个抽象类？数据类型



不叫继承，叫实现；

比抽象类更抽象的，叫做接口；

继承自学生父类，又实现了运动员接口；

一个行业约定；

接口，类似父类，由子类实现；

实现一个接口，也是这个接口的子类，可以向上强制类型转换；

也是强制完成，继承接口必须实现，除非你也是接口。

---

一切事物均有接口/功能；

代码重用，多态？



接口关键字：interface；

仍然会产生class文件，虽然声明 是interface

只包含功能声明的特殊类；

接口的方法

- public
- abstract
- 无成员变量？？？
  - 多重继承即可，**用抽象类继承抽象类！！！**
- implements（实现）





怎么继承的？？？不用手写继承接口？？



向下转型？向上转型？

test，都没看懂/

接口的 注意事项

- 接口多继承；

- 类与接口的功能可以重复，并不冲突；

  public static final——常量，值不可变、

  除了抽象方法以外只能是常量。



### 子类如果没有覆盖掉所有的抽象方法，则不能实例化，只能是抽象类

父类和子类，是一种

接口是功能的分离，不是种类

> 同学们双目无神，面露死相，毫无生机。

- 接口不可继承类；

抽象类中可以有非抽象方法？？

接口中全是抽象方法



多态？？？



java的访问修饰符:

- private 同一个类
- default 同一个包继承的类和子类
- protected 不同包继承的类和子类也可
- public 都行 

C++?

- private

  **私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有**类和友元函数**可以访问私有成员。

- protected

  **保护**成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。



强制类型转换？

强制数据类型转换

强制转换的格式是在需要转型的数据前加上“( )”，然后在括号内加入需要转化的数据类型。

**继承过程**中发生的**引用类型**转换

> 1、对象引用，均能指向其自身类型的对象实例
>
> Car c = new Car();
>
> 2、父类的应用可以根据需要将引用指向不同的子类对象，来调用不同的子类实现。这样父类引用的选择性将变得很灵活
>
> > 1. Vehicle v=new Vehicle(); 
> > 2. v=new Truck();
> > 3. Car c=new Truck();
>
> >  强制类型转换的只是引用类型，真正指向的对象是不会发生变化的，可以将引用看作看待对象的角度，层次。这就像可以将红富士看作苹果，也可以看作水果一样，看待的角度、层次虽然变了，但苹果还是那个苹果。	

> 1.向上转型：即父类引用指向子类对象,可以自动转换。如：
>
> Father father = new Son();  
>
> 这里的引用father指向内存中对象实质还是Son类型，不过对象的功能被临时削弱为father。
>
>  > Java 转型问题其实并不复杂，只要记住一句话：父类引用指向子类对象.
>>
> > 一般实际工作中person都会是一个接口，而接口不能new对象，就无法调用方法，这时候就要向上转型，再调用方法
>
> 2.向下转型：即强制类型转换。

转型——>泛型——>包装类型——>反射

### 泛型

什么是泛型，看表面的意思，泛型就是指广泛的、普通的类型。在java中是指把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。

> 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）

### 包装类型

基本数据类型由于这样的特性，导致无法参与转型，泛型，反射等过程。

将基本的数据类型以及一些辅助方法包装到类中











instance of？

---



static 修饰的成员 ，不属于某个对象，属于某个类；——类的成员

成员变量和成员函数属于实例；

成员变量或者成员方法；

用(类名.)直接访问

类似于公共的空调；

---

array list 用法？

java.util包的用法？？

switch的用法？

scanner用法？

throw用法？

---

### 类

- 成员变量
- 构造方法
- 普通方法
- getters/setters
  - Getter和Setter用于保护数据，尤其是在创建类时
  - 每个实例变量，getter方法将返回其值，而setter方法将设置或更新其值。 鉴于此，getter和setter也分别称为存取器和更改器
  - 按照惯例，getter以单词“ get”开头，setter以单词“ set”开头，后跟一个变量名。 在这两种情况下，变量名称的首字母均**大写**
  - 设置私有，然后setNumber……，保护数据

### Eclipse视图

- Package视图
- Navigator视图（真实文件视图）
- Outline（大纲视图，类的基本成员！）
  - 红色-private
  - 蓝色-defaulted
  - 黄色-protected
  - 绿色-public
  

### 引用类型数据内存

new 是申请一个堆空间；

main函数在栈空间中；

句柄拿的是堆空间地址；

```java
Person p = new Person("jack",18)
```

### this关键字

> 一般为对当前对象的引用；
>
> 类中不创建对象，this没有意义；
>
> 每个方法的this，对应着它 所在的那个对象；

### 匿名对象？

> ```java
> Person p = new Person();
> new Person().showName();
> ```
>
> 没有引用/没有名字的对象；
>
> 因为没有名字，所以在创建后立即调用自身方法；
>
> 无指针，所以是一次性的
>
> 但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口

### 异常

1. 语法错误-红线提示-编译错误；（编译不通过）
2. 逻辑错误（结果不是我们想要的）
3. 运行错误——异常

空指针？？

数组越界 ？？

---

异常的继承体系

Throwable？

- Error（致命错误？）程序无法处理
  - 服务器宕机？	
- Exception（异常的父类）上一级处理
  - RuntimeException(运行时异常,一般都是程序员犯的错误,需要修改源码的.

> 编译时异常:在编译时必须进行处理,不处理无法通过编译.

sc.next()，空格和回车都结束；

sc.nextln()，回车结束，空格接收；

### 异常处理

- 捕获处理

- 声明抛出处理

抛出：throws (IOException)

处理方式？

- try…catch(防止程序崩溃)

```java
try{
    FileWriter fw = new FileWriter(path);
    System.out.println("成功");
}
catch(){
    
}
```



十大常见 异常；

check exception（有红线，必须处理）

没红线，比如/0，没有红线



服务型程序？？

---

据说是重点，

正则表达式：

[a-z] 匹配a-z之间的一个任意字母。 





黑桃>红桃>梅花>方片；



### 组合关系

当一个类成为另一个类的成员变量后，我们把它们之间的关系称作是组合关系；

### 继承关系

代码复用的方式。

子类拥有所有父类的属性与方法；

可以继承私有_的内容空间，无法继承访问权限；

自己也继承了private，只是无法直接访问父类私有；

用法：

class 子类 extends 父类{}

继承，我是你的一种——“is a”.

private子类无法直接访问，可以通过public修饰的set、get进行访问；



### 包和main的关系

 一个类里面只能有一个main方法，但是一个包里面可以有好多类；

如果要是把程序打成jar包的话，就只能指定某个类中的main方法作为整个程序的入口；

>  java中的main方法是java应用程序的入口，java程序在运行时，首先调用执行main方法。但并不是说java中只能有一个main方法，不同类中都可以包含main方法。当JVM进行编译时，会提示选择其中一个main方法作为编译的入口。



### 继承的特点

Java支持单继承，但可以多层继承；

使用父类可以提高程序扩展性；

> 所有的类(除Object类)都有父类,所有的类都直接或间接是Object的子类



@Override——重写；

> 方法重写后，调用该方法时不再调用父类的方法，而调用子类重写后的方法。
>
> 子类重写父类的方法时在方法上添加 @Override注解,表示该方法是子类重写父类中的方法。
>
> 重写的访问权限相同或子类方法访问权限更大
>
> 子类的构造方法调用时，一定先调用父类的构造方法
>
> 子类的构造方法会先调用父类的无参构造，从而保证父类的相关内容会先于子类内容的初识化

```java
public Fu() {
		// super();
		System.out.println("父类的空参构造方法被调用了");
	}
```

>  super:父类存储空间
>
> main是在堆空间中的，栈是new申请的空间。
>



### 重载和重写的区别：

重载就是一个类中有多个同名方法，他们参数列表不同（返回值类型可随意，不能以返回类型作为重载函数的区分标准）；

> 是类以统一的方式处理不同类型数据的一种手段，类中多态性的体现。



重写是不同的类中，两者有继承关系时，子类重写父类的方法，且方法名与参数列表完全一致；

返回类型必须一直与被重写的方法相同，否则不能称其为重写

> 实质是子类对父类函数的重定义，体现了类间（父类与子类之间）的多态性。
>
> 子类函数的访问修饰权限不能小于父类的，若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法，如需父类中原有的方法则可使用 super 关键字。

























Linkedlist 和Arraylist实现了List 的接口；

Linkedlist多了好多对首尾的操作；

Arraylist增删比较慢，底层会拷贝并创建新数组，效率极低；

hashcode 散列 把值转换为 16进制数 会覆盖，次序有算法；

container

值类型比较值、引用类型比较地址，

字符串有字符串常量池，所以看起来一样，地址也一致；

> 值类型的比较：==（比较运算符）（简单数据类型没有equals方法）
>
> 值类型的包装类，拥有equals（比较值）、也可以用 ==
>
> 字符串中，== 比较的是地址，equals比较的是值；
>
> 引用类型 ==比较的地址，equals比较的还是地址。

值类型只比较值，引用类型只比较地址；

字符串特殊，==比较地址，equals比较值。

### === 

地址和值都相等——> "==="

