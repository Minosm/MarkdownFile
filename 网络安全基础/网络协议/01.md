传说中666的课程 ，无敌！

先学为敬！

实战工具，学过的再学一遍？？

浪费时间吧，，，

流媒体（跨平台）、即时通讯，编码问题？

都是协议？

软件开发人员，都是高素质的人才！

尊重他人！！！共同进步

---

### 网络协议

需求不同时，需要使用不同的协议。

场景不同，效率不同。

最佳选择往往是使用不同的协议，他们的底层都是大同小异的。

#### 网络编程

抓包、爬虫，都需要网络协议基础。

还要网络环境优化，第三方库？

ASF/OKHTTP3？

偏实战？

客户端-服务器开发？

- 客户端：浏览器（HTML、CSS、JS）
- 服务器：Java

网络抓包

- （chrome、firefox）
- fiddler（小提琴、骗子）、wire shark
  - charles和fiddler类似

模拟工具

- Xshell（win、**packet tracer、GNS3**

嵌入式开发，是机器人？C++？汇编？

###### 开发：

- 客户端
  - 移动开发
  - 嵌入式开发（机器人？
  - 前端开发
- 服务器/后台开发
  - Java、C++、PHP
  - .NET、Python、Go
- 全栈就是全都有

###### 客户端和后端进行交互，交互环境则是网络协议的内容

c++就是c plus plus 所以是cpp文件

###### c/c++跨平台：（编译多次）

- mac
  - mach-o（编译成）
- windows
  - PE（portable executable）
  - 可执行的 PE格式
- Linux
  - ELF格式

使用平台相关编译器，生成对应可执行文件后，可直接在操作系统上跑

这些对应执行文件都以段的形式来表示，对应的OS有对应的解释器去执行

> OS的功能就是读懂这些文件然后完成从磁盘文件到内存的映射工作，也就是适当的时候把文件的内容搬到内存适当的位置

可执行：OS直接读入内存，执行机器指令……

###### 关于PE文件

> 是 Win32环境自身所带的执行体文件格式，一些特性继承自 Unix的 Coff (common object file format)文件格式；
>
> win32平台都支持，无关CPU，只要有PE装载器即可，执行体会有略微差异。
>
> win NT（new tech~），服务器的OS
>
> ###### 格式：
>
> > DOS MZ header  （DOS可识别为有效执行体）
> >
> > > 包含偏移量，PE装载器会找到并跳过DOS stub
> >
> > DOS stub  （stub-票根、存根）用于显示PE错误提示
> >
> > > 如果在不支持PE的系统下，会显示“require Windows”
> > >
> > > stub 一般是自动生成
> >
> > PE header  
> >
> > > 包含装载器需要的各种域，如果有效则跳到PEheader尾部
> >
> > Section table  （节表）
> >
> > > 包含对应节的属性、文件偏移量、虚拟偏移量等
> > >
> > > 采用文件映射方法，将节映射到内存，附上节表里的属性
> >
> > Section 1  （根据不同节的属性-只读/…… 把内容划归到不同节内）
> > Section 2  
> > Section ...  
> > Section n  

> #### 步骤：
>
> 双击时，其实是shell（explorer.exe进程——GUI检测进程），是其它所有进程的入口？监听到之后会查看注册表，调用创建进程的函数（create process）
>
> 系统会创建一个对象（数据结构）存放**进程**信息，并维护句柄表
>

---

###### Java跨平台，只要编译一次（一次编译，到处运行）

不像C++，不同平台都要重新编译

编译出字节码文件，对操作系统来说，并不是可执行文件

###### 需要在不同操作系统上安装JVM-java virtual machine

启动后，可以加载字节码内容，翻译成**机器指令**（010101）

语法错误则不会生成字节码文件，Oracle提供JVM（JDK里有）

- JDK
  - JRE
    - JVM

类似于解释型语言，JS/PYTHON 

浏览器（V8引擎）解释（渲染）JS，也要转换成**机器指令**

服务器是ARM架构……

服务器端口监听，（运行软件才能监听，处理数据）

——服务器软件，用于监听端口，提供服务

返回数据也是相同的端口

---

项目小的时候，可以多个软件共用一个端口

如何区分？

- 部署项目（同一个软件下部署了三个项目）
- 服务器软件根据请求性质，选择不同项目去处理请求

分布式负载

### TomCat就是（Java）服务器软件：

帮助部署项目，不需要每个项目都重复实现监听的功能

服务器软件来监听端口并和部署在服务器软件上的项目进行交互

某些教材上也称中间件为容器，这也有一定的道理（项目的确是放在中间件里的，中间件又是放在JVM里的，他们又都在服务器里）

服务器软件往往“跑”在端口上（中间件）

Django也是中间件

###### TomCat本身就是Java开发的，所以他们都跑在JVM上

- 服务器
  - JVM
    - TomCat
      - Java代码

TomCat启动时会乱码，刻意去conf目录下把logging.properties

内的UTF-8改为GBK

##### 访问服务器软件：

>  通常Tomcat部署的Web项目请求URL为：`http://ip:port/project/index.jsp`
>
> - `ip`：`tomcat`部署服务器地址
> - `port`：`tomcat`绑定端口号
> - `project`：项目名称
> - `index.jsp`：具体访问页面

如何去访问资源？

客户端发送http请求:

- http:// IP地址 : 端口号 / 项目（上下文路径）/ 项目下的资源
- 先确定用啥协议去访问；
- // 通过IP找到服务器；
- : 端口号是为了确定具体的服务器软件；（有时候有多个服务器软件，用于端口负载？）
- / 上下文路径是为了路由到该服务器软件下的特定项目；
- / 该项目下有很多资源，要指定特定资源

##### 上下文路径：context path

例如：

http://117.169.101.44:8080/qq/img/1.jpg

http://117.169.101.44:8080/qq?username

http://117.169.101.44:8080/qq/login?username

> HTTP协议默认`80`端口访问，大部分网站`URL`不含端口号是因为都是使用的`80`端口
>
> - **Tomcat默认的访问端口为8080**，所以修改`Tomcat`端口号为`80`端口即可。
> - `Tomcat`目录下`conf`文件中的`server.xml`，在`Connector`标签中`port`属性修改为`80`。
> - 就可以不写端口号直接访问

访问TomCat（服务器软件）

http:// 自己的IP or 127.0.0.1 or localhost : 8080

127.0.0.1 保留字段，代表本机 

现在客户端和服务器都是自己

###### tomcat默认上下文路径是webapps

自己编写的项目就可以放在这个路径下了

协议就是一种约束，网络协议是规定节点之间交互（c-s）

为了方便全世界的计算机进行沟通 ，使用统一的协议去约束

如：

- 访问网页文件——http协议（可以是主页/索引页
- 文件传输协议——ftp协议

网络互连发展ISO的OSI参考模型（7层

真实是TCP/IP协议模型，

| OSI        | TCP/IP     | 高校/教材  |
| ---------- | ---------- | ---------- |
| 应用层     | 应用层     | 应用层     |
| 表示层     |            |            |
| 会话层     |            |            |
| 运输层     | 运输层     | 运输层     |
| 网络层     | 网际层     | 网络层     |
| 数据链路层 | 网络接口层 | 数据链路层 |
| 物理层     |            | 物理层     |
|            |            |            |

通信原理很重要，最底下两层

FTP\MQTT\RTMP\HTTP