50min

must match exactly

~~~python
imgHor = np.hstack((img1,img2))
imgVer = np.vstack((img1,img2))
~~~

必须是相同大小、相同通道数的图片

而且只能两个？





bitwise 按位的 wise（引导）



缩进快捷键

CTRL+]/[



---

# cv2.inRange函数

函数很简单，参数有三个
第一个参数：hsv指的是原图

第二个参数：lower_red指的是图像中低于这个lower_red的值，图像值变为0

> 实际还可以接受一个数组，包含三个值的数组（H、S、V）

第三个参数：upper_red指的是图像中高于这个upper_red的值，图像值变为0

而在lower_red～upper_red之间的值变成255



滤波器：

是对 图像进行平滑处理，降噪的过程；

有均值滤波、高斯滤波等；

原理：

首先取核，核是每次进行运算的最小单位；

均值直接取核内的平均值，高斯滤波是加权，再取平均值。

离中心点越近，权重越高。



## dst = cv2.GaussianBlur(src,ksize,sigmaX)

SRC : 图像

ksize： 核的大小，只能是奇数，如（3，3）、（5，5）、（7，7）

sigmaX：x方向方差，控制权重的

<img src="D:\File_Recv\日语学习\方差" alt="image-20201204190512829" style="zoom:33%;" /> 





---

Canny边缘检测算子是John F. Canny于 1986 年开发出来的一个多级边缘检测算法

　高斯滤波器的大小：第一步所用的平滑滤波器将会直接影响 Canny 算法的结果。较小的滤波器产生的模糊效果也较少，这样就可以检测较小、变化明显的细线。较大的滤波器产生的模糊效果也较多，将较大的一块图像区域涂成一个特定点的颜色值。这样带来的结果就是对于检测较大、平滑的边缘更加有用，例如彩虹的边缘。

阈值：使用两个阈值比使用一个阈值更加灵活，但是它还是有阈值存在的共性问题。设置的阈值过高，可能会漏掉重要信息；阈值过低，将会把枝节信息看得很重要。很难给出一个适用于所有图像的通用阈值。目前还没有一个经过验证的实现方法。

---

retrieve :取回；

# hierarchy 层次

#### threshold阈值；

# perimeter周长

comma 逗号

aspect ratio 宽高比

**vector** 矢量；



NumPy 最重要的一个特点是其 N 维数组对象 **ndarray**，它是一系列同类型数据的集合

**curve：**

曲线；弯曲；曲面；弧线

